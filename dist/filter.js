"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var glShader = require("gl-shader");
var glslify = require("glslify");
var glFbo = require("gl-fbo");
var _draw = require("a-big-triangle");
var ExposureSettings = require("./exposure_settings");
var _ = require("lodash");

var Filter = function () {
  function Filter(gl, json) {
    _classCallCheck(this, Filter);

    this.gl = gl;
    this.shader = glShader(this.gl, "precision mediump float;\n#define GLSLIFY 1\n\nattribute vec2 position;\nvarying vec2 screenPosition;\n\nvoid main() {\n  screenPosition = (position + 1.0) * 0.5;\n  gl_Position = vec4(position, 1.0, 1.0);\n}", "precision mediump float;\n#define GLSLIFY 1\nvarying vec2 screenPosition;\nuniform sampler2D texture;\n\n// controls brightness\n// min - 0\n// max - 2\n// default - 1\nuniform float brightness;\n\n// controls contrast\n// min - 0.0\n// max - 3.0\n// default - 1.0\nuniform float contrast;\n\n// determines which values are raised and which are lowered\n// min - 0.0\n// max - 1.0\n// default - 0.5\nuniform float mid;\n\n// these are all the level settings\n// color settings range from 0.0 to 1.0\n// default min is 0.0\n// default max is 1.0\n// gamma ranges from 0.0 to 9.99, default is 1.0\nuniform float rgb_in_min;\nuniform float rgb_in_max;\nuniform float rgb_out_min;\nuniform float rgb_out_max;\nuniform float rgb_gamma;\n\nuniform float r_in_min;\nuniform float r_in_max;\nuniform float r_out_min;\nuniform float r_out_max;\nuniform float r_gamma;\n\nuniform float g_in_min;\nuniform float g_in_max;\nuniform float g_out_min;\nuniform float g_out_max;\nuniform float g_gamma;\n\nuniform float b_in_min;\nuniform float b_in_max;\nuniform float b_out_min;\nuniform float b_out_max;\nuniform float b_gamma;\n\n// these control the curves settings\n// each texture represents the mapping of color values\nuniform sampler2D rgb_curve_points;\nuniform bool rgb_curve_enabled;\n\nuniform sampler2D r_curve_points;\nuniform bool r_curve_enabled;\n\nuniform sampler2D g_curve_points;\nuniform bool g_curve_enabled;\n\nuniform sampler2D b_curve_points;\nuniform bool b_curve_enabled;\n\n// HSL\nuniform float hue;\nuniform float saturation;\nuniform float lightness;\n\nuniform float cyans_hue;\nuniform float cyans_saturation;\n\nuniform float magentas_hue;\nuniform float magentas_saturation;\n\nuniform float yellows_hue;\nuniform float yellows_saturation;\n\nuniform float reds_hue;\nuniform float reds_saturation;\n\nuniform float greens_hue;\nuniform float greens_saturation;\n\nuniform float blues_hue;\nuniform float blues_saturation;\n\n// selective color controls\nuniform float cyans_cyan_shift;\nuniform float cyans_magenta_shift;\nuniform float cyans_yellow_shift;\nuniform float cyans_black_shift;\nuniform float cyans_red_shift;\nuniform float cyans_green_shift;\nuniform float cyans_blue_shift;\nuniform float cyans_gray_shift;\nuniform float cyans_white_shift;\n\nuniform float magentas_cyan_shift;\nuniform float magentas_magenta_shift;\nuniform float magentas_yellow_shift;\nuniform float magentas_black_shift;\nuniform float magentas_red_shift;\nuniform float magentas_green_shift;\nuniform float magentas_blue_shift;\nuniform float magentas_gray_shift;\nuniform float magentas_white_shift;\n\nuniform float yellows_cyan_shift;\nuniform float yellows_magenta_shift;\nuniform float yellows_yellow_shift;\nuniform float yellows_black_shift;\nuniform float yellows_red_shift;\nuniform float yellows_green_shift;\nuniform float yellows_blue_shift;\nuniform float yellows_gray_shift;\nuniform float yellows_white_shift;\n\nuniform float reds_cyan_shift;\nuniform float reds_magenta_shift;\nuniform float reds_yellow_shift;\nuniform float reds_black_shift;\nuniform float reds_red_shift;\nuniform float reds_green_shift;\nuniform float reds_blue_shift;\nuniform float reds_gray_shift;\nuniform float reds_white_shift;\n\nuniform float greens_cyan_shift;\nuniform float greens_magenta_shift;\nuniform float greens_yellow_shift;\nuniform float greens_black_shift;\nuniform float greens_red_shift;\nuniform float greens_green_shift;\nuniform float greens_blue_shift;\nuniform float greens_gray_shift;\nuniform float greens_white_shift;\n\nuniform float blues_cyan_shift;\nuniform float blues_magenta_shift;\nuniform float blues_yellow_shift;\nuniform float blues_black_shift;\nuniform float blues_red_shift;\nuniform float blues_green_shift;\nuniform float blues_blue_shift;\nuniform float blues_gray_shift;\nuniform float blues_white_shift;\n\nuniform float blacks_cyan_shift;\nuniform float blacks_magenta_shift;\nuniform float blacks_yellow_shift;\nuniform float blacks_black_shift;\nuniform float blacks_red_shift;\nuniform float blacks_green_shift;\nuniform float blacks_blue_shift;\nuniform float blacks_gray_shift;\nuniform float blacks_white_shift;\n\nuniform float grays_cyan_shift;\nuniform float grays_magenta_shift;\nuniform float grays_yellow_shift;\nuniform float grays_black_shift;\nuniform float grays_red_shift;\nuniform float grays_green_shift;\nuniform float grays_blue_shift;\nuniform float grays_gray_shift;\nuniform float grays_white_shift;\n\nuniform float whites_cyan_shift;\nuniform float whites_magenta_shift;\nuniform float whites_yellow_shift;\nuniform float whites_black_shift;\nuniform float whites_red_shift;\nuniform float whites_green_shift;\nuniform float whites_blue_shift;\nuniform float whites_gray_shift;\nuniform float whites_white_shift;\n\nfloat mix_factor(vec4 range, vec3 hsl) {\n  float mix_factor = 0.0;\n\n  if (hsl.x >= range.x && hsl.x <= range.w) {\n    // lower range\n    if (hsl.x >= range.x && hsl.x < range.y) {\n      mix_factor = smoothstep(range.x, range.y, hsl.x);\n    }\n\n    // target range\n    if (hsl.x >= range.y && hsl.x <= range.z) {\n      mix_factor = 1.0;\n    }\n\n    // upper range\n    if (hsl.x > range.z && hsl.x <= range.w) {\n      mix_factor = 1.0 - smoothstep(range.z, range.w, hsl.x);\n    }\n  }\n\n  vec2 lightness_range = vec2(0.0, 0.08333);\n  vec2 saturation_range = vec2(0.0, 0.08333);\n  mix_factor *= smoothstep(saturation_range.x, saturation_range.y, hsl.y);\n  mix_factor *= smoothstep(lightness_range.x, lightness_range.y, hsl.z);\n\n  return mix_factor;\n}\n\n// Returns a number between 0 and 1 as if the number line is circular\n// 1.1 => 0.1\n// -0.1 => 0.9\nfloat clamp_continuous(float value) {\n  float unit = value;\n\n  if (unit > 1.0) {\n    unit = mod(unit, 1.0);\n  } else if (unit < 0.0) {\n    unit = 1.0 + unit;\n  }\n\n  return unit;\n}\n\n// These functions based on http://www.chilliant.com/rgb2hsv.html\nvec3 HUEtoRGB(float h) {\n  float r = abs(h * 6.0 - 3.0) - 1.0;\n  float g = 2.0 - abs(h * 6.0 - 2.0);\n  float b = 2.0 - abs(h * 6.0 - 4.0);\n  return clamp(vec3(r, g, b), 0.0, 1.0);\n}\n\nvec3 RGBtoHCV(vec3 RGB) {\n  float Epsilon = 0.00000000001;\n  // Based on work by Sam Hocevar and Emil Persson\n  vec4 P = (RGB.g < RGB.b) ? vec4(RGB.bg, -1.0, 2.0/3.0) : vec4(RGB.gb, 0.0, -1.0/3.0);\n  vec4 Q = (RGB.r < P.x) ? vec4(P.xyw, RGB.r) : vec4(RGB.r, P.yzx);\n  float C = Q.x - min(Q.w, Q.y);\n  float H = abs((Q.w - Q.y) / (6.0 * C + Epsilon) + Q.z);\n  return vec3(H, C, Q.x);\n}\n\nvec3 RGBtoHSL(vec3 RGB) {\n  float Epsilon = 0.00000000001;\n  vec3 HCV = RGBtoHCV(RGB);\n  float L = HCV.z - HCV.y * 0.5;\n  float S = HCV.y / (1.0 - abs(L * 2.0 - 1.0) + Epsilon);\n  return vec3(HCV.x, S, L);\n}\n\nvec3 HSLtoRGB(vec3 HSL) {\n  vec3 RGB = HUEtoRGB(HSL.x);\n  float C = (1.0 - abs(2.0 * HSL.z - 1.0)) * HSL.y;\n  return (RGB - 0.5) * C + HSL.z;\n}\n\nvoid main() {\n  vec4 color = texture2D(texture, vec2(screenPosition.s, screenPosition.t));\n  float alpha = color.a;\n\n  ////////////////////////////\n  /////// brightness /////////\n  ////////////////////////////\n  color = mix(color, vec4(1.0, 1.0, 1.0, 1.0), brightness - 1.0);\n  color.a = 1.0;\n\n  ////////////////////////////\n  //////// contrast //////////\n  ////////////////////////////\n  color.r = ((color.r - mid) * contrast) + mid;\n  color.g = ((color.g - mid) * contrast) + mid;\n  color.b = ((color.b - mid) * contrast) + mid;\n  color.a = 1.0;\n\n  ////////////////////////////\n  ///////// levels ///////////\n  ////////////////////////////\n  // First adjust levels based on all channels\n  // Map the color according to the new min and max\n  color = min(max(color - rgb_in_min, 0.0)/(rgb_in_max - rgb_in_min), 1.0);\n  color.a = 1.0;\n\n  // Gamma correction\n  color = pow(color, vec4(1.0 / rgb_gamma));\n  color.a = 1.0;\n\n  // Linear interpolation based on output values\n  // returns min * (1 - color) + max * color\n  color = mix(vec4(rgb_out_min), vec4(rgb_out_max), color);\n  color.a = 1.0;\n\n  // Then adjust channels seperately\n  color.r = min(max(color.r - r_in_min, 0.0)/(r_in_max - r_in_min), 1.0);\n  color.r = pow(color.r, (1.0 / r_gamma));\n  color.r = mix(r_out_min, r_out_max, color.r);\n  color.a = 1.0;\n\n  color.g = min(max(color.g - g_in_min, 0.0)/(g_in_max - g_in_min), 1.0);\n  color.g = pow(color.g, (1.0 / g_gamma));\n  color.g = mix(g_out_min, g_out_max, color.g);\n  color.a = 1.0;\n\n  color.b = min(max(color.b - b_in_min, 0.0)/(b_in_max - b_in_min), 1.0);\n  color.b = pow(color.b, (1.0 / b_gamma));\n  color.b = mix(b_out_min, b_out_max, color.b);\n  color.a = 1.0;\n\n  ////////////////////////////\n  ///////   curves   /////////\n  ////////////////////////////\n\n  // rgb curves\n  if (rgb_curve_enabled) {\n    float in_r = clamp(color.r, 0.0001, 0.9999);\n    float in_g = clamp(color.g, 0.0001, 0.9999);\n    float in_b = clamp(color.b, 0.0001, 0.9999);\n\n    float out_r = texture2D(rgb_curve_points, vec2(in_r, 0.5)).x;\n    float out_g = texture2D(rgb_curve_points, vec2(in_g, 0.5)).x;\n    float out_b = texture2D(rgb_curve_points, vec2(in_b, 0.5)).x;\n\n    color.r = clamp(mix(0.0, 1.0, out_r), 0.0, 1.0);\n    color.g = clamp(mix(0.0, 1.0, out_g), 0.0, 1.0);\n    color.b = clamp(mix(0.0, 1.0, out_b), 0.0, 1.0);\n  }\n\n  // r curves\n  if (r_curve_enabled) {\n    float in_r = clamp(color.r, 0.0001, 0.9999);\n    float out_r = texture2D(r_curve_points, vec2(in_r, 0.5)).x;\n    color.r = clamp(mix(0.0, 1.0, out_r), 0.0, 1.0);\n  }\n\n  // g curves\n  if (g_curve_enabled) {\n    float in_g = clamp(color.g, 0.0001, 0.9999);\n    float out_g = texture2D(g_curve_points, vec2(in_g, 0.5)).x;\n    color.g = clamp(mix(0.0, 1.0, out_g), 0.0, 1.0);\n  }\n\n  // b curves\n  if (b_curve_enabled) {\n    float in_b = clamp(color.b, 0.0001, 0.9999);\n    float out_b = texture2D(b_curve_points, vec2(in_b, 0.5)).x;\n    color.b = clamp(mix(0.0, 1.0, out_b), 0.0, 1.0);\n  }\n\n  ////////////////////////////\n  ////         HSL        ////\n  ////////////////////////////\n\n  vec3 hsl = RGBtoHSL(color.rgb);\n\n  // Color ranges here\n  // https://gist.github.com/actionnick/d184d17e39d1669759204bcb8eaad501\n\n  vec4 MASTER_RANGE = vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 CYAN_RANGE = vec4(0.375, 0.4583, 0.54167, 0.625);\n  vec4 MAGENTA_RANGE = vec4(0.7083, 0.79167, 0.875, 0.9583);\n  vec4 YELLOW_RANGE = vec4(0.04167, 0.125, 0.2083, 0.29167);\n  vec4 RED_RANGE_1 = vec4(0.875, 0.9583, 1.0, 1.0); // Red is a special case because it goes from 315 -> 45 degrees\n  vec4 RED_RANGE_2 = vec4(0.0, 0.0, 0.04167, 0.125);\n  vec4 GREEN_RANGE = vec4(0.2083, 0.29167, 0.375, 0.4583);\n  vec4 BLUE_RANGE = vec4(0.54167, 0.625, 0.7083, 0.79167);\n\n  // Master\n  float master_mix_factor = mix_factor(MASTER_RANGE, hsl);\n  hsl.x = clamp_continuous(hsl.x + (hue * master_mix_factor));\n  hsl.y = clamp(hsl.y + (saturation * master_mix_factor), 0.0, 1.0);\n  hsl.z = clamp(mix(hsl.z, 1.0, max(0.0, lightness)), 0.0, 1.0);\n  hsl.z = clamp(mix(hsl.z, 0.0, abs(min(0.0, lightness))), 0.0, 1.0);\n\n  // Cyan\n  float cyans_mix_factor = mix_factor(CYAN_RANGE, hsl);\n  hsl.x = clamp_continuous(hsl.x + (cyans_hue * cyans_mix_factor));\n  hsl.y = clamp(hsl.y + (cyans_saturation * cyans_mix_factor), 0.0, 1.0);\n\n  // Magentas\n  float magentas_mix_factor = mix_factor(MAGENTA_RANGE, hsl);\n  hsl.x = clamp_continuous(hsl.x + (magentas_hue * magentas_mix_factor));\n  hsl.y = clamp(hsl.y + (magentas_saturation * magentas_mix_factor), 0.0, 1.0);\n\n  // Yellows\n  float yellows_mix_factor = mix_factor(YELLOW_RANGE, hsl);\n  hsl.x = clamp_continuous(hsl.x + (yellows_hue * yellows_mix_factor));\n  hsl.y = clamp(hsl.y + (yellows_saturation * yellows_mix_factor), 0.0, 1.0);\n\n  // Reds\n  float reds_mix_factor = max(mix_factor(RED_RANGE_1, hsl), mix_factor(RED_RANGE_2, hsl));\n  hsl.x = clamp_continuous(hsl.x + (reds_hue * reds_mix_factor));\n  hsl.y = clamp(hsl.y + (reds_saturation * reds_mix_factor), 0.0, 1.0);\n\n  // Greens\n  float greens_mix_factor = mix_factor(GREEN_RANGE, hsl);\n  hsl.x = clamp_continuous(hsl.x + (greens_hue * greens_mix_factor));\n  hsl.y = clamp(hsl.y + (greens_saturation * greens_mix_factor), 0.0, 1.0);\n\n  // Blues\n  float blues_mix_factor = mix_factor(BLUE_RANGE, hsl);\n  hsl.x = clamp_continuous(hsl.x + (blues_hue * blues_mix_factor));\n  hsl.y = clamp(hsl.y + (blues_saturation * blues_mix_factor), 0.0, 1.0);\n\n  color.rgb = HSLtoRGB(hsl);\n\n  ////////////////////////////\n  ////  selective color   ////\n  ////////////////////////////\n\n  vec3 CYAN = vec3(0.0, 1.0, 1.0);\n  vec3 MAGENTA = vec3(1.0, 0.0, 1.0);\n  vec3 YELLOW = vec3(1.0, 1.0, 0.0);\n  vec3 BLACK = vec3(0.0, 0.0, 0.0);\n  vec3 RED = vec3(1.0, 0.0, 0.0);\n  vec3 GREEN = vec3(0.0, 1.0, 0.0);\n  vec3 BLUE = vec3(0.0, 0.0, 1.0);\n  vec3 WHITE = vec3(1.0, 1.0, 1.0);\n  vec3 GRAY = vec3(0.5, 0.5, 0.5);\n  float MAX_DISTANCE = length(vec3(1.0, 1.0, 1.0));\n\n  // cyans\n  color.rgb = mix(color.rgb, (CYAN * color.rgb), cyans_mix_factor * cyans_cyan_shift);\n  color.rgb = mix(color.rgb, (MAGENTA * color.rgb), cyans_mix_factor * cyans_magenta_shift);\n  color.rgb = mix(color.rgb, (YELLOW * color.rgb), cyans_mix_factor * cyans_yellow_shift);\n  color.rgb = mix(color.rgb, (RED * color.rgb), cyans_mix_factor * cyans_red_shift);\n  color.rgb = mix(color.rgb, (GREEN * color.rgb), cyans_mix_factor * cyans_green_shift);\n  color.rgb = mix(color.rgb, (BLUE * color.rgb), cyans_mix_factor * cyans_blue_shift);\n  color.rgb = mix(color.rgb, WHITE, cyans_mix_factor * cyans_white_shift);\n  color.rgb = mix(color.rgb, GRAY, cyans_mix_factor * cyans_gray_shift);\n  color.rgb = mix(color.rgb, BLACK, cyans_mix_factor * cyans_black_shift);\n\n  // magentas\n  color.rgb = mix(color.rgb, (CYAN * color.rgb), magentas_mix_factor * magentas_cyan_shift);\n  color.rgb = mix(color.rgb, (MAGENTA * color.rgb), magentas_mix_factor * magentas_magenta_shift);\n  color.rgb = mix(color.rgb, (YELLOW * color.rgb), magentas_mix_factor * magentas_yellow_shift);\n  color.rgb = mix(color.rgb, (RED * color.rgb), magentas_mix_factor * magentas_red_shift);\n  color.rgb = mix(color.rgb, (GREEN * color.rgb), magentas_mix_factor * magentas_green_shift);\n  color.rgb = mix(color.rgb, (BLUE * color.rgb), magentas_mix_factor * magentas_blue_shift);\n  color.rgb = mix(color.rgb, WHITE, magentas_mix_factor * magentas_white_shift);\n  color.rgb = mix(color.rgb, GRAY, magentas_mix_factor * magentas_gray_shift);\n  color.rgb = mix(color.rgb, BLACK, magentas_mix_factor * magentas_black_shift);\n\n  // yellows\n  color.rgb = mix(color.rgb, (CYAN * color.rgb), yellows_mix_factor * yellows_cyan_shift);\n  color.rgb = mix(color.rgb, (MAGENTA * color.rgb), yellows_mix_factor * yellows_magenta_shift);\n  color.rgb = mix(color.rgb, (YELLOW * color.rgb), yellows_mix_factor * yellows_yellow_shift);\n  color.rgb = mix(color.rgb, (RED * color.rgb), yellows_mix_factor * yellows_red_shift);\n  color.rgb = mix(color.rgb, (GREEN * color.rgb), yellows_mix_factor * yellows_green_shift);\n  color.rgb = mix(color.rgb, (BLUE * color.rgb), yellows_mix_factor * yellows_blue_shift);\n  color.rgb = mix(color.rgb, WHITE, yellows_mix_factor * yellows_white_shift);\n  color.rgb = mix(color.rgb, GRAY, yellows_mix_factor * yellows_gray_shift);\n  color.rgb = mix(color.rgb, BLACK, yellows_mix_factor * yellows_black_shift);\n\n  // reds\n  color.rgb = mix(color.rgb, (CYAN * color.rgb), reds_mix_factor * reds_cyan_shift);\n  color.rgb = mix(color.rgb, (MAGENTA * color.rgb), reds_mix_factor * reds_magenta_shift);\n  color.rgb = mix(color.rgb, (YELLOW * color.rgb), reds_mix_factor * reds_yellow_shift);\n  color.rgb = mix(color.rgb, (RED * color.rgb), reds_mix_factor * reds_red_shift);\n  color.rgb = mix(color.rgb, (GREEN * color.rgb), reds_mix_factor * reds_green_shift);\n  color.rgb = mix(color.rgb, (BLUE * color.rgb), reds_mix_factor * reds_blue_shift);\n  color.rgb = mix(color.rgb, WHITE, reds_mix_factor * reds_white_shift);\n  color.rgb = mix(color.rgb, GRAY, reds_mix_factor * reds_gray_shift);\n  color.rgb = mix(color.rgb, BLACK, reds_mix_factor * reds_black_shift);\n\n  // greens\n  color.rgb = mix(color.rgb, (CYAN * color.rgb), greens_mix_factor * greens_cyan_shift);\n  color.rgb = mix(color.rgb, (MAGENTA * color.rgb), greens_mix_factor * greens_magenta_shift);\n  color.rgb = mix(color.rgb, (YELLOW * color.rgb), greens_mix_factor * greens_yellow_shift);\n  color.rgb = mix(color.rgb, (RED * color.rgb), greens_mix_factor * greens_red_shift);\n  color.rgb = mix(color.rgb, (GREEN * color.rgb), greens_mix_factor * greens_green_shift);\n  color.rgb = mix(color.rgb, (BLUE * color.rgb), greens_mix_factor * greens_blue_shift);\n  color.rgb = mix(color.rgb, WHITE, greens_mix_factor * greens_white_shift);\n  color.rgb = mix(color.rgb, GRAY, greens_mix_factor * greens_gray_shift);\n  color.rgb = mix(color.rgb, BLACK, greens_mix_factor * greens_black_shift);\n\n  // blues\n  color.rgb = mix(color.rgb, (CYAN * color.rgb), blues_mix_factor * blues_cyan_shift);\n  color.rgb = mix(color.rgb, (MAGENTA * color.rgb), blues_mix_factor * blues_magenta_shift);\n  color.rgb = mix(color.rgb, (YELLOW * color.rgb), blues_mix_factor * blues_yellow_shift);\n  color.rgb = mix(color.rgb, (RED * color.rgb), blues_mix_factor * blues_red_shift);\n  color.rgb = mix(color.rgb, (GREEN * color.rgb), blues_mix_factor * blues_green_shift);\n  color.rgb = mix(color.rgb, (BLUE * color.rgb), blues_mix_factor * blues_blue_shift);\n  color.rgb = mix(color.rgb, WHITE, blues_mix_factor * blues_white_shift);\n  color.rgb = mix(color.rgb, GRAY, blues_mix_factor * blues_gray_shift);\n  color.rgb = mix(color.rgb, BLACK, blues_mix_factor * blues_black_shift);\n\n  // blacks\n  float black_distance = length(BLACK - color.rgb);\n  float black_mix_factor = pow(1.0 - (black_distance / MAX_DISTANCE), 5.0);\n\n  color.rgb = mix(color.rgb, CYAN, black_mix_factor * blacks_cyan_shift);\n  color.rgb = mix(color.rgb, MAGENTA, black_mix_factor * blacks_magenta_shift);\n  color.rgb = mix(color.rgb, YELLOW, black_mix_factor * blacks_yellow_shift);\n  color.rgb = mix(color.rgb, BLACK, black_mix_factor * blacks_black_shift);\n  color.rgb = mix(color.rgb, RED, black_mix_factor * blacks_red_shift);\n  color.rgb = mix(color.rgb, GREEN, black_mix_factor * blacks_green_shift);\n  color.rgb = mix(color.rgb, BLUE, black_mix_factor * blacks_blue_shift);\n  color.rgb = mix(color.rgb, WHITE, black_mix_factor * blacks_white_shift);\n  color.rgb = mix(color.rgb, GRAY, black_mix_factor * blacks_gray_shift);\n\n  // grays\n  float gray_distance = length(GRAY - color.rgb);\n  float gray_mix_factor = pow(1.0 - (gray_distance / MAX_DISTANCE), 5.0);\n\n  color.rgb = mix(color.rgb, CYAN, gray_mix_factor * grays_cyan_shift);\n  color.rgb = mix(color.rgb, MAGENTA, gray_mix_factor * grays_magenta_shift);\n  color.rgb = mix(color.rgb, YELLOW, gray_mix_factor * grays_yellow_shift);\n  color.rgb = mix(color.rgb, BLACK, gray_mix_factor * grays_black_shift);\n  color.rgb = mix(color.rgb, RED, gray_mix_factor * grays_red_shift);\n  color.rgb = mix(color.rgb, GREEN, gray_mix_factor * grays_green_shift);\n  color.rgb = mix(color.rgb, BLUE, gray_mix_factor * grays_blue_shift);\n  color.rgb = mix(color.rgb, WHITE, gray_mix_factor * grays_white_shift);\n  color.rgb = mix(color.rgb, GRAY, gray_mix_factor * grays_gray_shift);\n\n  // whites\n  float white_distance = length(WHITE - color.rgb);\n  float white_mix_factor = pow(1.0 - (white_distance / MAX_DISTANCE), 5.0);\n\n  color.rgb = mix(color.rgb, CYAN, white_mix_factor * whites_cyan_shift);\n  color.rgb = mix(color.rgb, MAGENTA, white_mix_factor * whites_magenta_shift);\n  color.rgb = mix(color.rgb, YELLOW, white_mix_factor * whites_yellow_shift);\n  color.rgb = mix(color.rgb, BLACK, white_mix_factor * whites_black_shift);\n  color.rgb = mix(color.rgb, RED, white_mix_factor * whites_red_shift);\n  color.rgb = mix(color.rgb, GREEN, white_mix_factor * whites_green_shift);\n  color.rgb = mix(color.rgb, BLUE, white_mix_factor * whites_blue_shift);\n  color.rgb = mix(color.rgb, WHITE, white_mix_factor * whites_white_shift);\n  color.rgb = mix(color.rgb, GRAY, white_mix_factor * whites_gray_shift);\n\n  // always preserve alpha\n  color.a = alpha;\n  gl_FragColor = color;\n}\n");
    this.shader.attributes.position.location = 0;
    this.fbo = glFbo(gl, [gl.drawingBufferWidth, gl.drawingBufferHeight]);
    this.fbo.color[0].minFilter = gl.LINEAR;
    this.fbo.color[0].magFilter = gl.LINEAR;

    this.settings = new ExposureSettings(json);
  }

  _createClass(Filter, [{
    key: "bind",
    value: function bind() {
      this.fbo.bind();
      this.fbo.shape = [this.gl.drawingBufferWidth, this.gl.drawingBufferHeight];
    }
  }, {
    key: "unbind",
    value: function unbind() {
      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
    }
  }, {
    key: "setUniforms",
    value: function setUniforms() {
      var _this = this;

      var settings = this.settings;
      var uniforms = this.shader.uniforms;
      _.keys(ExposureSettings.PROPS).forEach(function (key) {
        if (ExposureSettings.PROPS[key].virtual) {
          return;
        }

        if (ExposureSettings.PROPS[key].setUniform) {
          ExposureSettings.PROPS[key].setUniform(_this);
        } else {
          uniforms[key] = settings[key];
        }
      });
    }
  }, {
    key: "draw",
    value: function draw() {
      var gl = this.gl;

      this.unbind();

      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);

      this.shader.bind();
      this.shader.uniforms.texture = this.fbo.color[0].bind(0);
      this.setUniforms();

      _draw(gl);
    }
  }, {
    key: "settings",
    get: function get() {
      return this._settings;
    },
    set: function set(settings) {
      var _this2 = this;

      if (this._settings) {
        this._settings.removeAllListeners("updated");
      }

      settings.addListener("updated", function () {
        return _this2.draw();
      });
      this._settings = settings;
      this.draw();
    }
  }]);

  return Filter;
}();

module.exports = Filter;
